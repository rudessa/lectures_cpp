# Лекция 4. Auto. Последовательные контейнеры. (21.01.2022)

## Ключевое слово auto 
_(появилось в C++11)_

auto - ключевое слово, которое говорит, что нужно определить тип переменной при компиляции по правой части присваивания


```python
auto number = 1; // int
```

__Ссылки и auto__:


```python
auto number = 1;
int& number_ref = number;

auto number2 = number_ref;  // здесь auto = int
```

Если хотим сделать auto ссылку:


```python
auto& number2 = number_ref;
```

Часто встречается константная ссылка:


```python
const auto& number2 = Func();
```

__Плюсы auto__:
- auto позволяет написать код, который будет работать, даже если какие-то типы поменяются
- сокращение очень длинных типов
- хорошо применяется в шаблонных классах и функциях

__Минусы auto__:
- auto делает код менее понятным

Где еще встречается auto:


```python
// Функции

auto Func() {       // auto смотрит на возвращаемый тип
    return ...;
}
```

Лучше стараться избегать использование auto в качестве типа возвращаемого значения. Кроме необходимых случаев - сложных шаблонов.

## Массивы

Массив - последовательная область памяти.

Массивы используются для:
- низкоуровневая работа с памятью
- реализация низкоуровневых производительных алгоритмов
- контейнеры стандратной библиотеки

Инициализация массива:


```python
int numbers[5] = {0};               // [0, 0, 0, 0, 0]. Работает только для 0!
int numbers[5] = {1, 2, 3, 4, 5};   // [1, 2, 3, 4, 5]
int numbers[5] = {1};               // [1, 0, 0, 0, 0]
```


```python
numbers[i] - доступ к элементу массива
```

__Двумерные массивы__


```python
int numbers[2][3] = {{0, 1, 2}, {4, 5, 6}}; 

// массив из 2-x элементов, каждый элемент которого - массив из 3-x элементов
```

Массив всегда передается в функцию как указатель на его начало:


```python
void PrintSize(int arr[4]) { // arr имеет тип - указатель на int
    ...
}
```

Массивы используются редко.

## C-строки


```python
const char str[] = "Hello";
```

Строки в C-стиле представляют из себя массив, в котором столько элементов, сколько букв + прибавляется "\0".

Реализация вывода в стандратный поток: 
бежит по строке, пока не встретит символ равный 0.

Сравнение строк:


```python
#include <cstring>
std::strcmp(str1, str2); // 0 - строки равны
                         // <0 - левая меньше, чем правая
                         // >0 - правая меньше, чем левая
```

С-строки не очень удобные, поэтому придумали std::string

## STD::STRING

Нужно подключать библиотеку string.

Внутри std::string выделен массив, также string хранит size массива


```python
str1.size()        // получить длину строки (кол-во символов в строке)
str1.c_str()       // достать C-строку из std::string
str1.data()        // аналог c_str
```

Строки можно сравнивать через знаки равно:


```python
str1 == str2
str1 < str2
str1 <= str2
```

Строки можно складывать:


```python
str1 + str2
str1.append(str2)  // аналогично +=
```

Вхождение другой строки (вернет индекс начала подстроки)


```python
str1.find("ll")  
```

Другие функции:


```python
std::to_string(10)  // преобразовать число в строку
std::stoi(str1)     // преобразовать из строки в число
```

## STD::VECTOR

Для работы с векторами подключается библиотека vector.

Вектор - список, который хранится последовательно в памяти.

__Имплементация вектора__ состоит из 3-x полей:
1. указатель на начало буфера
2. size - количество уже занятых элементов
3. capacity - длина всего выделенного буфера 

Если size становится равен capacity, то: 
1. создается новый буфер длины больше предыдущего (например, в 2 раза больше)
2. предыдущий буфер копируется в начало нового буфера
3. новый элемент добавляется в следующую свободную ячейку
4. capacity становится равным длине нового буфера

Внутри <> пишется тип элемента вектора:


```python
std::vector<int> = {1, 2, 3};
```

Нам не нужно заранее знать рамер вектора.

Чтобы добавить что-то в конец есть специальный символ:


```python
numbers.push_back(3);
```

Итератор - объект, который указывает на элемент коллекции.
- begin -  указывает на первый элемент
- end  - указывает на следующий элемент после последнего заполненного
- rbegin - указывает на последний элемент
- rend - указывает на элемент перед нулевым 

!Плохая итерация:


```python
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (size_t i = 0; i < numbers.size(); ++i) {
    std::cout << numbers.at(i) << std::endl;
}
```

Пройтись по всем элементам вектора (__range-based for__):


```python
std::vector<int> numbers = {1, 2, 3, 4, 5};
for (const auto& n : numbers) {
    std::cout << n << std::endl;            
}
```

Некоторые методы:


```python
numbers.capacity()        // возвращает capacity
numbers.front()           // значение нулевого элемента
numbers.back()            // значение последнего элемента
numbers.reserve(100)      // выделяет буфер желательного размера
numbers.shrink_to_fit();  // уменьшить capacity (до = size)
numbers.pop_back()        // достает элнемент с конца
numbers2.swap(numbers);   // меняет содержимое 2-х коллекций (эффективная операция)
```

- похож на вектор, но имеет фиксированный размер
- вообще не нужен

## Array

Нужно подключить array

Array похож на vector, но имеет фиксированный размер


```python
#include <array>
std::array<int, 5> numbers = {1, 2, 3, 4, 5};
std::array<int, 5> numbers2 = {1, 2, 3};       // эквивалентно [1, 2, 3, 0, 0]
```

Нет методов, которые меняют размер (push_back, pop_back)

Не понятно зачем нужен

## STD::LIST

Реализация двусвязного списка. 

- есть методы begin и end
- нельзя обратиться к элементу через []

Чтобы получить какой-то элемент нужно совершить O(n) операция

__Плюсы std::list__:
- позволяет дешево вставлять элементы в любое место за O(1)

Есть метод, который удаляет все вхождения соотвествующего значения:


```python
numbers.remove(1); // в векторе неэффективен
```


```python
numbers.sort()           // сортировка
numbers.unique()         // удаляет одинаковые элементы, которые идут подряд

numbers1.merge(numbers2) // если два листа отсортированы
```

## STD::FORWARD_LIST

Односвязный список

- у итератора нет --
- нет методов rbegin, rend

## STD::DEQUE

Смесь вектора и листа

- есть доступ по индексу
- эффективная вставка в любое место
