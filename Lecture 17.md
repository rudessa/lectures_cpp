# Лекция 17 — 15.03.2022

## Debug и Тестирование

### Общий процесс

- Попробовать собрать программу;
- Запуск функций по отдельности с выводом;
- Пробуем печатать в начале / в конце функции, до / после цикла;

→ Вывод на экран — самый наивный подход, помогает в ситуациях, где взаимодействие с программой ограничено;

→ Логгирование:

- Логгер — специальный класс / библиотека, печатает вывод в конфигурируемую среду;
- Можно писать например ошибки — в файл с ошибками, предупреждения — тоже в отдельный файл;
- Замена печати — более управляемая → можно управлять настройками, куда что логгируется, не пересобирая бинарник;
- В C++ нет логгера стандартной библиотеки, но есть в сторонних;

### Debugger

- Дебаггер — программа, имеющая доступ к бинарному коду нашей программы, может заходить внутрь, показывать вывод, останавливать исполнение и тд. → для этого надо программу собрать в специальном режиме дебага (сохранаяется отладочная информация, не происходит оптимизаций);
- Существует дебаггер в IDE и в консоли (GDB), на Линуксе — IDE-шный тоже через GDB;
- Ставим break points на полях:
    - “Пометка” для дебаггера — в этом месте надо остановиться и войти в интерактивный режим;
    - Можем посмотреть стэк каждой функции → далее делаем step into / step out / step over:
        - Step over — выполняет следующую строчку кода, оставаясь на этом же уровне стэка;
        - Step into — заходим в функцию / код, который на данной строчке;
        - Step out — возвращение обратно по стэку на ту функцию / строчку, откуда мы изначально вызывали step into;
    - У них можно написать условия (помогает отладить специфичный случай и остановиться в определённый момент лишь тогда, когда надо — не надо постоянно нажимать step over);
    - Можно написать свои переменные или выражения внутрь стэка — они могут выдать текущий размер массива или результат логического сравнения (true / false);
        - Можно написать внутрь дебаггера функцию и дебаггер рядом с ней напишет, что запуск такого кода вернёт;
- Стандартные контейнеры (как vector, map…) в дебаггере будут отображены с помощью pretty printer скрипта — сразу человекочитаемый вид, а не «указатель на буфер + size + capacity», как обычно реализован vector;
    - Можно посмотреть содержание вектора (все элементы);

### Тестирование

→ Много видов;

1. Интеграционные тесты — проверка всей системы в плане взаимодействия всех компонент друг с другом и передачу верных типов;
2. Функциональные тесты — проверка результатов / значений на верность (на разумный диапазон);
3. Unit тесты — тесты разложенные на минимальные единицы, которую можно переиспользовать в нашем коде → тесты на отдельные функции / классы;
4. Performance тесты — проверка на быстроту выполнения программы;
5. UX тесты — проверка на удобность и верность работы интерфейса для пользователя;

**Unit тесты:**

- Самые актуальные для наших задач;
- При импорте open-source библиотеки важно прогнать unit тесты, прикладываемые к ней, чтобы понять, что на нашей системе библиотека работает так, как надо;
- Нужны для рефакторинга — код должен быть покрыт тестами, лишь тогда у нас будет уверенность, что при исправлении одной части мы поймаем поломку другой, завязанной на неё (там упадёт тест);
- Тесты помогают рефакторить;
- Хорошие тесты выполняют роль документации к коду;

**Хорошие тесты:**

- Независимы друг от друга (нельзя в одном тесте объявлять переменную, которые используются в другом тесте);
- Возпроизводируемы → от запуска к запуску одни и те же результаты;
    
    → Проблемные примеры:
    
    - Если используется текущее время;
    - Если используется рандомное значение — добавляем один и тот же seed;
- Тесты должны повторять структуру кода — для каждой пары файлов .cpp + .h отдельный файл с тестом (работает разбиение на небольшие куски);
- Тесты должны сразу указывать на то, что сломалось;
- Тесты должны быть быстрыми;
- Перед каждой интеграцией в github / gitlab — надо прогонять тесты (continuous integration — система, которая помогает замерджить программы используя тестирование);

**Библиотеки / тестовые фреймворки:**

- Catch — у нас на курсе, выгода, что импортируется в одном файле;
- GTest (Google Test);
- Все обладают аналогичным функционалом;

**Написание тестового файла:**

- Создаём .cpp файл с тестами — превращаются в отдельный бинарный файл:

```cpp
#include <gtest/gtest.h> // заголовок библиотеки для тестирования

// набор тест кейсов:
TEST(LectureTest, Simple) { // новый тест кейс
	// LectureTest — тест сюит, название набора тестов (например, для определённой программы)
	// → разные сьюиты можно запускать по одельности из IDE	

	// Simple — название тест кейса
	...
}
```

- Тест сюита — набор тест кейсов, объединённых семантической частью (например, для одной функции);
- Тест кейс — единица проверки в тестах, минимальная часть, которую можно запустить независимо;
    - Обычно проверяет 1 функцию или метод и лишь одно свойство данного метода;

+ Надо дописать определённый код в CMake.txt → смотрим [в документации](https://google.github.io/googletest/quickstart-cmake.html):

```cpp
include(FetchContent)
FetchContent_Declare(
  googletest
  URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip
)

// For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
FetchContent_MakeAvailable(googletest)
```

- Добавляем новый executable;
- Но: бинарный файл нельзя слинковаться с бинарным файлом → мы должны разделить код на 3 файла: библиотека, основной файл, тестовый файл:
    - Выносим тестируемый кусок кода в библиотеку и добавляем отдельно в CMake:
        
        ```cpp
        //... здесь код для запуска gtest
        
        add_library(search
        	search.cpp // именно здесь будет лежать тестируемый код и он слинкуется с lecture.cpp
        )
        
        add_executable(lecture
        	lecture.cpp
        )
        
        target_link_libraries(
        	search
        )
        
        // далее:
        enable_testing()
        
        add executable(
        	lecture_test
        	lecture_test.cpp
        )
        
        target_link_libraries(
        	lecture_test
        	gtest_main
        	search
        )
        
        include(GoogleTest)
        gtest_discover_tests(lecture_test)
        ```
        
    - Код разделяем следующим образом: в search.h — объявление функций, которые хотим тестировать, в search.cpp — определение тестируемых функций, в lecture_test — тесты;
- Макросы:
    
    → Макросы = команды препроцессора, отрабатывают до компиляции;
    
    - `TEST` — заменяется на код с классом, где вызывается метод проверки;
    - Набор `EXPECT_` макросов:
        
        ```cpp
        TEST(LectureTest, Simple) {
        	EXPECT_FLOAT_EQ(2 * 3, 6); // проверяет два float/double числа на эквивалентность с точностью до эпсилон
        	EXPECT_GT(2 * 3, 6); // is greater
        	EXPECT_GE(2 * 3, 6); // is greater or equal
        	EXPECT_EQ(2 * 3, 6); // is equal
        	EXPECT_TRUE(IsPrime(2)); // is true
        	EXPECT_FALSE(IsPrime(9)); // is false
        	// ... и прочие макросы сравнения
        }
        ```
        
- Тесты можно запускать не все — можно фильтровать, иначе они могут все каждый раз выполняться долго;
- Аналогичный макрос `ASSERT_TRUE`, но он прерывает выполнение теста в момент, когда настаёт первая ошибка;
- Всегда используем `EXPECT` если дальнейшее выполнение программы имеет смысл (а например проверку на пустоту объекта — через `ASSERT`, так как дальнейшие выполнение проверок на содержание не имеет смысла);
- Лучше, чтобы тесты писали свой вывод в поток, а не создавали доп. файлы;
- Обработка исключений — макросы `EXPECT_THROW / EXPECT_NO_THROW`;
- Можно добавить вывод человекочитаемого сообщения при падении тест кейса — синтаксис совпадает с выводом в поток;
- `Setup / TearDown` — выполнение дополнительного кода до / после отработки каждого кейса;
- `SetupTestSuit / TearDownTestSuit` — выполнение дополнительного кода до / после отработки каждого сьюта;

**Составление хорошего тест кейса:**

- Полное покрытие — прогон всех диапазонов значений (но долго);
- Желательно декомпозировать тесты на конечное количество;
- Разбиваем все кейсы на классы эквивалентности → в каких случаях программа идёт себя одинаково;
    - Выбираем corner cases → особые случаи;
    - Можем посмотреть на сам код — любой `if` добавляет один вариант исхода, который надо протестировать.
